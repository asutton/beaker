#ifndef BEAKER_FRONTEND_LOCATION_HPP
#define BEAKER_FRONTEND_LOCATION_HPP

#include <cassert>
#include <iosfwd>

namespace beaker
{
  /// Represents a location in a source file.
  ///
  /// A location is invalid (or unknown) if the line is 0.
  ///
  /// TODO: We also have a notion of a builtin location. It's not unknown,
  /// just generated by the compiler.
  ///
  /// FIXME: This needs to move to a higher-level library so that source
  /// locations can appear in ASTs. Also, we'll eventually need to bind
  /// locations to source files, possibly through modules. There are a bunch
  /// of techniques we can use to minimize the size of this object.
  struct Source_location
  {
    std::size_t line = {};
    std::size_t column = {};

    /// Converts to true if the location is valid.
    explicit operator bool () const
    {
      return is_valid();
    }

    /// Returns true if the location is valid.
    bool is_valid() const
    {
      return line != 0;
    }

    /// Returns true if the location is invalid.
    bool is_invalid() const
    {
      return line == 0;
    }
  };

  /// Represents a range of characters in a source file.
  ///
  /// A range is invalid if its start location is invalid. Note that the
  /// start being valid implies that the end is valid.
  struct Source_range
  {
    Source_range() = default;

    Source_range(Source_location s, Source_location e)
      : start(s), end(e)
    {
      assert(s.is_valid() == e.is_valid());
    }

    /// Converts to true if the range is valid.
    explicit operator bool () const
    {
      return is_valid();
    }

    /// Returns true if the range is valid.
    bool is_valid() const
    {
      return start.is_valid();
    }

    /// Returns true if the rang is invalid.
    bool is_invalid() const
    {
      return start.is_invalid();
    }

    /// Returns true if the range includes characters on a single line. The
    /// name "span" comes from HTML.
    bool is_span() const
    {
      return start.line == end.line;
    }

    /// Returns true if the range refers to or spans a single character.
    /// This is useful when generating carets for diagnostics.
    bool is_location() const
    {
      return is_span() && (end.column - start.column <= 1);
    }
    
    /// Returns true if the range includes characters on multiple lines.
    bool is_region() const
    {
      return start.line != end.line;
    }

    Source_location start = {};
    Source_location end = {};
  };

  // I/O

  std::ostream& operator<<(std::ostream& os, Source_location const& loc);
  std::ostream& operator<<(std::ostream& os, Source_range const& range);

} // namespace beaker

#endif
